---
title: "多階層記憶システム 階層定義"
date: "2025-03-23"
author: "HARCA開発チーム"
version: "1.0.0"
status: "ドラフト"
---

# 多階層記憶システム 階層定義

*作成日: 2025年3月23日*
*更新日: 2025年3月23日*

## 1. 概要

本ドキュメントでは、HARCA多階層記憶システムの各記憶階層（短期・中期・長期）の詳細定義を行います。各階層の特性、役割、データ構造、および相互作用について明確に定義し、システム全体における位置づけを明らかにします。

## 2. 記憶階層の基本構造

HARCA多階層記憶システムは、人間の記憶モデルを参考に、以下の3つの主要な階層で構成されます：

1. **短期記憶（Short-Term Memory）**
   - 揮発性の高い一時的な情報を保持
   - 高速アクセスが必要な情報を管理
   - 主にRedisを使用して実装

2. **中期記憶（Mid-Term Memory）**
   - 中程度の持続性を持つ情報を保持
   - コンテキスト依存の情報を管理
   - 主にPostgreSQLを使用して実装

3. **長期記憶（Long-Term Memory）**
   - 長期間保持される永続的な情報を管理
   - 構造化された知識と経験を保存
   - PostgreSQLとpgvectorを使用して実装

## 3. 短期記憶（Short-Term Memory）

### 3.1 定義と役割

短期記憶は、システムの作業記憶（Working Memory）として機能し、現在のタスクや会話に関連する一時的な情報を保持します。情報の保持期間は比較的短く、高速なアクセスが要求されます。

### 3.2 主要コンポーネント

#### 3.2.1 作業記憶（Working Memory）

- **定義**: 現在処理中のタスクや会話に関する一時的な情報を保持するコンポーネント
- **特性**:
  - 揮発性が高い（デフォルトTTL: 15分）
  - 高速読み書きが可能
  - 容量制限あり（設定可能、デフォルト: 1000アイテム）
- **主な用途**:
  - 会話の直近のターン（最大10ターン）
  - 現在のタスクの状態
  - 一時的な計算結果
  - ユーザーの短期的な意図や目標

#### 3.2.2 コンテキストマネージャー（Context Manager）

- **定義**: 現在のコンテキスト（会話やタスクの文脈）を管理するコンポーネント
- **特性**:
  - コンテキスト切り替えを管理
  - コンテキスト間の関連性を追跡
  - 中程度の揮発性（デフォルトTTL: 60分）
- **主な用途**:
  - 会話コンテキストの追跡
  - マルチタスク環境でのコンテキスト切り替え
  - 関連コンテキスト間のリンク管理

### 3.3 データ構造

#### 3.3.1 作業記憶アイテム（WorkingMemoryItem）

```javascript
{
  id: String,                 // 一意のID
  content: Object,            // 記憶内容（任意の形式）
  type: String,               // 記憶タイプ（会話、タスク、計算結果など）
  createdAt: Timestamp,       // 作成時刻
  expiresAt: Timestamp,       // 有効期限
  priority: Number,           // 優先度（1-10）
  contextId: String,          // 関連コンテキストID
  metadata: {                 // メタデータ
    source: String,           // 情報ソース
    confidence: Number,       // 信頼度（0.0-1.0）
    tags: Array<String>       // タグリスト
  }
}
```

#### 3.3.2 コンテキスト（Context）

```javascript
{
  id: String,                 // コンテキストID
  name: String,               // コンテキスト名
  type: String,               // コンテキストタイプ（会話、タスク、セッションなど）
  createdAt: Timestamp,       // 作成時刻
  updatedAt: Timestamp,       // 最終更新時刻
  expiresAt: Timestamp,       // 有効期限
  parentContextId: String,    // 親コンテキストID（オプション）
  relatedContextIds: Array<String>, // 関連コンテキストIDリスト
  metadata: {                 // メタデータ
    status: String,           // 状態（アクティブ、一時停止、完了など）
    priority: Number,         // 優先度（1-10）
    tags: Array<String>       // タグリスト
  }
}
```

### 3.4 操作と機能

- **保存（Store）**: 新しい記憶アイテムを短期記憶に保存
- **取得（Retrieve）**: IDまたはクエリに基づいて記憶アイテムを取得
- **更新（Update）**: 既存の記憶アイテムを更新
- **削除（Delete）**: 記憶アイテムを削除
- **検索（Search）**: メタデータや内容に基づいて記憶アイテムを検索
- **フィルタリング（Filter）**: 特定の条件に基づいて記憶アイテムをフィルタリング
- **昇格（Promote）**: 重要な短期記憶を中期記憶に昇格
- **コンテキスト管理（Context Management）**: コンテキストの作成、更新、切り替え

### 3.5 実装技術

- **主要技術**: Redis
- **データ形式**: JSON
- **インデックス**: Redis Search
- **通信プロトコル**: Redis Protocol

## 4. 中期記憶（Mid-Term Memory）

### 4.1 定義と役割

中期記憶は、短期記憶よりも長い期間保持される情報を管理し、エピソード記憶（過去の会話や相互作用）とユーザープロファイル情報を保持します。情報の保持期間は中程度で、構造化されたデータの保存と検索が主な機能です。

### 4.2 主要コンポーネント

#### 4.2.1 エピソード記憶（Episodic Memory）

- **定義**: 過去の会話やタスクの履歴を保持するコンポーネント
- **特性**:
  - 中程度の持続性（デフォルト保持期間: 30日）
  - 時系列データとして構造化
  - コンテキスト情報と関連付け
- **主な用途**:
  - 会話履歴の保存
  - ユーザーとの過去のやり取りの記録
  - タスクの実行履歴
  - 問題解決プロセスの記録

#### 4.2.2 ユーザープロファイル（User Profile）

- **定義**: ユーザーに関する情報を保持するコンポーネント
- **特性**:
  - 長期的な持続性（ユーザーが明示的に削除するまで保持）
  - ユーザー固有の情報を構造化
  - 継続的に更新される
- **主な用途**:
  - ユーザー設定
  - ユーザー嗜好
  - ユーザースキルレベル
  - ユーザー行動パターン

### 4.3 データ構造

#### 4.3.1 エピソードアイテム（EpisodeItem）

```javascript
{
  id: String,                 // 一意のID
  type: String,               // エピソードタイプ（会話、タスク、問題解決など）
  content: Object,            // エピソード内容
  startTime: Timestamp,       // 開始時刻
  endTime: Timestamp,         // 終了時刻
  contextId: String,          // 関連コンテキストID
  participants: Array<String>, // 参加者（ユーザーID、システムなど）
  summary: String,            // エピソードの要約
  importance: Number,         // 重要度（1-10）
  relatedEpisodeIds: Array<String>, // 関連エピソードIDリスト
  metadata: {                 // メタデータ
    outcome: String,          // 結果（成功、失敗、未完了など）
    tags: Array<String>,      // タグリスト
    emotions: Object,         // 感情分析結果（オプション）
    location: String          // 場所情報（オプション）
  }
}
```

#### 4.3.2 ユーザープロファイルアイテム（UserProfileItem）

```javascript
{
  userId: String,             // ユーザーID
  preferences: {              // ユーザー設定
    language: String,         // 言語設定
    theme: String,            // テーマ設定
    notificationSettings: Object, // 通知設定
    privacySettings: Object   // プライバシー設定
  },
  skills: {                   // スキル情報
    programmingLanguages: Array<Object>, // プログラミング言語スキル
    domains: Array<Object>,   // ドメイン知識
    tools: Array<Object>      // ツール習熟度
  },
  behavior: {                 // 行動パターン
    activeHours: Array<Object>, // アクティブ時間帯
    interactionFrequency: Object, // 相互作用頻度
    responsePatterns: Object  // 応答パターン
  },
  history: {                  // 履歴サマリー
    firstInteraction: Timestamp, // 初回相互作用時刻
    lastInteraction: Timestamp,  // 最終相互作用時刻
    totalInteractions: Number,   // 総相互作用回数
    completedTasks: Number    // 完了タスク数
  },
  metadata: {                 // メタデータ
    createdAt: Timestamp,     // プロファイル作成時刻
    updatedAt: Timestamp,     // 最終更新時刻
    version: String,          // プロファイルバージョン
    tags: Array<String>       // タグリスト
  }
}
```

### 4.4 操作と機能

- **保存（Store）**: 新しいエピソードやプロファイル情報を保存
- **取得（Retrieve）**: IDまたはクエリに基づいて情報を取得
- **更新（Update）**: 既存の情報を更新
- **削除（Delete）**: 情報を削除（論理削除を優先）
- **検索（Search）**: メタデータや内容に基づいて検索
- **時系列分析（Temporal Analysis）**: 時間に基づく分析と検索
- **昇格（Promote）**: 重要な中期記憶を長期記憶に昇格
- **降格（Demote）**: 不要になった中期記憶を削除または圧縮

### 4.5 実装技術

- **主要技術**: PostgreSQL
- **データ形式**: JSONB
- **インデックス**: GIN、B-tree
- **通信プロトコル**: SQL、RESTful API

## 5. 長期記憶（Long-Term Memory）

### 5.1 定義と役割

長期記憶は、システムの永続的な知識ベースとして機能し、長期間保持される構造化された情報を管理します。セマンティック記憶（概念や事実）と手続き記憶（ルールやプロセス）を含み、高度な検索と推論機能を提供します。

### 5.2 主要コンポーネント

#### 5.2.1 知識ベース（Knowledge Base）

- **定義**: 構造化された知識と概念を保持するコンポーネント
- **特性**:
  - 永続的な保持（明示的に削除されるまで保持）
  - 高度に構造化されたデータ
  - セマンティックリンクを持つ
- **主な用途**:
  - ドメイン知識の保存
  - 概念間の関係の表現
  - 事実と定義の保存
  - 参照情報の管理

#### 5.2.2 ルールエンジン（Rule Engine）

- **定義**: 手続き的知識とルールを管理するコンポーネント
- **特性**:
  - ルールベースの推論をサポート
  - 条件と行動のマッピング
  - 優先順位と競合解決メカニズム
- **主な用途**:
  - ビジネスルールの管理
  - 意思決定ロジックの実装
  - ワークフロー定義
  - 自動化ルールの管理

### 5.3 データ構造

#### 5.3.1 知識アイテム（KnowledgeItem）

```javascript
{
  id: String,                 // 一意のID
  type: String,               // 知識タイプ（概念、事実、定義など）
  name: String,               // 名前
  content: Object,            // 知識内容
  description: String,        // 説明
  createdAt: Timestamp,       // 作成時刻
  updatedAt: Timestamp,       // 最終更新時刻
  source: String,             // 情報ソース
  confidence: Number,         // 信頼度（0.0-1.0）
  vector: Array<Number>,      // 埋め込みベクトル
  relations: [                // 関係性
    {
      relationType: String,   // 関係タイプ（is-a、has-a、part-ofなど）
      targetId: String,       // 関連知識アイテムID
      strength: Number,       // 関係の強さ（0.0-1.0）
      metadata: Object        // 関係メタデータ
    }
  ],
  metadata: {                 // メタデータ
    domain: String,           // ドメイン
    tags: Array<String>,      // タグリスト
    version: String,          // バージョン
    accessCount: Number       // アクセス回数
  }
}
```

#### 5.3.2 ルールアイテム（RuleItem）

```javascript
{
  id: String,                 // 一意のID
  name: String,               // ルール名
  description: String,        // 説明
  condition: {                // 条件
    type: String,             // 条件タイプ（単純、複合）
    expression: String,       // 条件式
    parameters: Object        // 条件パラメータ
  },
  action: {                   // アクション
    type: String,             // アクションタイプ
    function: String,         // 実行関数
    parameters: Object        // アクションパラメータ
  },
  priority: Number,           // 優先度（1-10）
  status: String,             // 状態（有効、無効）
  createdAt: Timestamp,       // 作成時刻
  updatedAt: Timestamp,       // 最終更新時刻
  metadata: {                 // メタデータ
    author: String,           // 作成者
    version: String,          // バージョン
    tags: Array<String>,      // タグリスト
    executionCount: Number    // 実行回数
  }
}
```

### 5.4 操作と機能

- **保存（Store）**: 新しい知識やルールを保存
- **取得（Retrieve）**: IDまたはクエリに基づいて情報を取得
- **更新（Update）**: 既存の情報を更新
- **削除（Delete）**: 情報を削除（論理削除を優先）
- **検索（Search）**: キーワード、ベクトル、関係性に基づいて検索
- **推論（Inference）**: 既存の知識に基づいて新しい知識を推論
- **ルール評価（Rule Evaluation）**: 条件に基づいてルールを評価
- **知識グラフ操作（Knowledge Graph Operations）**: 知識グラフの操作と分析

### 5.5 実装技術

- **主要技術**: PostgreSQL、pgvector
- **データ形式**: JSONB、ベクトル
- **インデックス**: GIN、IVFFlat（ベクトル）
- **通信プロトコル**: SQL、GraphQL API

## 6. 階層間の相互作用

### 6.1 記憶の昇格（Memory Promotion）

記憶の昇格は、下位階層の記憶を上位階層に移動するプロセスです。

#### 6.1.1 短期記憶から中期記憶への昇格

- **トリガー条件**:
  - 重要度が閾値を超える（デフォルト: 7/10以上）
  - 繰り返しアクセスされる（デフォルト: 5回以上）
  - 明示的な昇格要求がある
  - 関連する他の記憶が既に昇格している

- **昇格プロセス**:
  1. 短期記憶アイテムを選択
  2. 中期記憶形式に変換
  3. エピソード記憶またはユーザープロファイルに保存
  4. 短期記憶内の元のアイテムにリンクを追加
  5. 必要に応じて短期記憶から削除

#### 6.1.2 中期記憶から長期記憶への昇格

- **トリガー条件**:
  - 長期的な重要性が高い（デフォルト: 8/10以上）
  - 繰り返しアクセスされる（デフォルト: 10回以上）
  - パターンとして認識される
  - 明示的な昇格要求がある

- **昇格プロセス**:
  1. 中期記憶アイテムを選択
  2. 長期記憶形式に変換（知識アイテムまたはルールアイテム）
  3. 埋め込みベクトルを生成
  4. 関連する既存の長期記憶との関係を確立
  5. 知識ベースまたはルールエンジンに保存
  6. 中期記憶内の元のアイテムにリンクを追加

### 6.2 記憶の降格（Memory Demotion）

記憶の降格は、上位階層の記憶を下位階層に移動するか、削除するプロセスです。

#### 6.2.1 中期記憶の降格

- **トリガー条件**:
  - 保持期間が終了
  - 重要度が低下
  - アクセス頻度が低い
  - ストレージ最適化が必要

- **降格プロセス**:
  1. 降格対象の中期記憶アイテムを選択
  2. 要約または圧縮バージョンを作成（オプション）
  3. アーカイブまたは削除

#### 6.2.2 長期記憶の降格

- **トリガー条件**:
  - 情報が古くなった
  - 信頼度が低下
  - 競合する新しい情報が追加された
  - 明示的な降格要求がある

- **降格プロセス**:
  1. 降格対象の長期記憶アイテムを選択
  2. 履歴バージョンとしてアーカイブ
  3. 関連する記憶アイテムへのリンクを更新
  4. 必要に応じて新しいバージョンを作成

### 6.3 階層間の検索と統合

#### 6.3.1 階層横断検索（Cross-Tier Search）

- **プロセス**:
  1. 検索クエリを受信
  2. 各記憶階層に適切な形式でクエリを変換
  3. 並行して各階層で検索を実行
  4. 結果を統合し、重複を除去
  5. 関連性と信頼度に基づいてランク付け
  6. 統合された結果を返す

#### 6.3.2 記憶統合（Memory Integration）

- **プロセス**:
  1. 関連する記憶アイテムを特定
  2. 記憶間の関係を分析
  3. 矛盾や重複を解決
  4. 統合された記憶表現を作成
  5. 必要に応じて元の記憶アイテムを更新

## 7. 実装ガイドライン

### 7.1 短期記憶実装ガイドライン

- Redis Hashを使用してメモリアイテムを保存
- Redis Streamsを使用してイベントストリームを管理
- Redis Setsを使用してコンテキスト関連付けを管理
- Redis Expirationを使用してTTLを管理
- Redis Search（RedisSearch）を使用して検索機能を実装

### 7.2 中期記憶実装ガイドライン

- PostgreSQLテーブルを使用してエピソードとプロファイルデータを保存
- JSONBデータ型を使用して柔軟なスキーマをサポート
- GINインデックスを使用してJSONBフィールドの検索を最適化
- 時系列データに適したインデックス戦略を実装
- パーティショニングを使用して大規模データセットを管理

### 7.3 長期記憶実装ガイドライン

- PostgreSQLとpgvectorを使用してベクトル検索をサポート
- 知識グラフ構造を実装するための関係テーブルを設計
- IVFFlatインデックスを使用してベクトル検索を最適化
- ルール評価エンジンを実装するためのプロシージャを設計
- キャッシュ戦略を実装して頻繁にアクセスされる知識の取得を最適化

## 8. 結論

本ドキュメントでは、HARCA多階層記憶システムの各記憶階層（短期・中期・長期）の詳細定義を行いました。各階層の特性、役割、データ構造、および相互作用について明確に定義し、システム全体における位置づけを明らかにしました。この定義に基づいて、各記憶階層の実装を進めることで、効率的で柔軟な多階層記憶システムを構築することができます。
