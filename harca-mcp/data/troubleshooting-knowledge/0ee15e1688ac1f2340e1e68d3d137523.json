{
  "id": "0ee15e1688ac1f2340e1e68d3d137523",
  "title": "Redis PubSubトラブルシューティングレポート（全体）",
  "source": "troubleshooting-redis-pubsub",
  "category": "distributed-cache",
  "technology": [
    "redis",
    "pubsub",
    "caching"
  ],
  "date": "2025-03-24T22:55:59.355Z",
  "sectionIndex": 0,
  "wordCount": 312,
  "charCount": 4102,
  "content": "# Redis PubSubトラブルシューティングレポート\n\n## 概要\n\nRedis PubSubを使用した分散キャッシュ無効化機能において、無限ループとキャッシュキー生成の不一致という2つの重大な問題を特定し、解決しました。このドキュメントでは、問題の詳細な分析、解決策、および学んだ教訓を記録します。\n\n## 問題1: キャッシュキー生成の不一致\n\n### 問題の詳細\nEmbeddingCacheクラスとRedisCacheManagerクラスで異なるハッシュアルゴリズムを使用してキャッシュキーを生成していました：\n- EmbeddingCache: SHA-256ハッシュ（generateKeyメソッド）\n- RedisCacheManager: MD5ハッシュ（_getCacheKeyメソッド）\n\nこれにより、同じテキストとモデル名に対して異なるキーが生成され、キャッシュの無効化が正しく機能していませんでした。\n\n### 問題の影響\n- 同じデータに対して複数のキャッシュエントリが作成される\n- キャッシュ無効化イベントが正しく伝播されない\n- メモリとストレージの無駄な使用\n\n### 解決策\n1. EmbeddingCacheのgetメソッドを修正：\n   ```javascript\n   // 修正前\n   const redisResult = await this.redisCache.get(key);\n   \n   // 修正後\n   const redisResult = await this.redisCache.get(text, modelName);\n   ```\n\n2. EmbeddingCacheのdeleteメソッドを修正：\n   ```javascript\n   // 修正前\n   await this.redisCache.delete(key);\n   this.redisCache.publishInvalidationEvent(key, modelName);\n   \n   // 修正後\n   await this.redisCache.delete(text, modelName);\n   this.redisCache.publishInvalidationEvent(text, modelName);\n   ```\n\n3. RedisCacheManagerのpublishInvalidationEventメソッドを修正：\n   ```javascript\n   // 修正前\n   publishInvalidationEvent(key, modelName) {\n     this._publishMessage('invalidate', key, { modelName });\n   }\n   \n   // 修正後\n   publishInvalidationEvent(text, modelName) {\n     const key = this._getCacheKey(text, modelName);\n     this._publishMessage('invalidate', key, { modelName });\n   }\n   ```\n\n## 問題2: clearModelCacheメソッドの無限ループと伝播の問題\n\n### 問題の詳細\nテストが `モデル test-model-1 のキャッシュをクリアします...` から進まなくなる問題を特定しました。`clearModelCache`メソッドに複数の問題がありました：\n\n1. **無限ループの問題**：\n   - EmbeddingCacheのclearModelCacheメソッドがRedisCacheManagerのclearModelCacheメソッドを呼び出す\n   - RedisCacheManagerが'clearModel'イベントを発行する\n   - EmbeddingCacheの'clearModel'イベントリスナーが再びclearModelCacheメソッドを呼び出す\n   - これにより無限ループが発生する\n\n2. **ファイルキャッシュの処理問題**：\n   - ファイル名のパターンマッチングが正しく機能していない\n   - 実際のファイル名パターンと一致していない正規表現を使用\n\n3. **Redis PubSub伝播の問題**：\n   - RedisCacheManagerのclearModelCacheメソッドでのキー検索が適切でない\n   - モデル名に基づくキー検索が正しく行われていない\n\n### 問題の影響\n- テストが無限ループに陥り、完了しない\n- CPU使用率の急上昇\n- Redis接続の過負荷\n- メモリリーク\n\n### 解決策\n\n#### 1. 無限ループの解決\nEmbeddingCacheのclearModelCacheメソッドを修正：\n```javascript\n// 修正前\nif (this.config.enableRedisCache && this.redisCache && sourceInstanceId !== this.config.instanceId) {\n  await this.redisCache.clearModelCache(modelName, this.config.instanceId);\n}\n\n// 修正後\nif (this.config.enableRedisCache && this.redisCache && sourceInstanceId !== this.instanceId) {\n  await this.redisCache.clearModelCache(modelName, this.instanceId);\n}\n```\n\nイベントリスナーでの自分自身が発行したイベントを無視する処理を追加：\n```javascript\n// 送信元のインスタンスIDを確認\nif (sourceInstance === this.instanceId) {\n  console.log('自分自身が発行したイベントのため、処理をスキップします');\n  return;\n}\n```\n\n#### 2. ファイルキャッシュの処理修正\nファイル内容を読み取ってmodelNameをチェックするように変更：\n```javascript\n// ファイル内容を読み取ってmodelNameをチェックする\nfor (const file of files) {\n  const filePath = path.join(this.config.cacheDir, file);\n  try {\n    // ファイルの内容を読み取る\n    const fileContent = fs.readFileSync(filePath, 'utf8');\n    const cacheEntry = JSON.parse(fileContent);\n    \n    // モデル名が一致するかチェック\n    if (cacheEntry && cacheEntry.modelName === modelName) {\n      fs.unlinkSync(filePath);\n      deletedCount++;\n    }\n  } catch (fileError) {\n    console.error(`ファイル ${file} の処理中にエラーが発生しました:`, fileError);\n  }\n}\n```\n\n#### 3. Redis PubSub伝播の修正\nRedisCacheManagerのclearModelCacheメソッドを修正：\n```javascript\n// 修正前\nconst keys = await this.redis.keys(`${this.config.keyPrefix}:*`);\n\n// 修正後\nconst keys = await this.redis.keys(`${this.config.keyPrefix}*`);\n```\n\n## テスト結果\n\n修正後、テストが正常に完了し、以下の点が確認されました：\n- キャッシュインスタンスが正常に初期化される\n- データの設定と取得が正常に機能する\n- モデルキャッシュのクリア処理が正しく動作し、無限ループが発生しない\n- 自分自身が発行したイベントは適切にスキップされる\n\n## 学んだ教訓\n\n1. **分散システムの設計における注意点**\n   - イベント伝播時の無限ループを防ぐためのソースIDチェックの重要性\n   - 同一データに対する一貫したキー生成の必要性\n\n2. **テスト設計の改善点**\n   - タイムアウト設定の重要性（無限ループの早期検出）\n   - 詳細なログ出力によるデバッグの容易化\n\n3. **コード品質の向上策**\n   - インスタンスIDの参照を統一（config.instanceId vs instanceId）\n   - ファイル操作時の適切なエラーハンドリング\n\n4. **将来の改善案**\n   - ユニットテストの追加（特にエッジケースのテスト）\n   - パフォーマンスモニタリングの強化\n   - 自動リカバリーメカニズムの実装\n\n## 結論\n\nRedis PubSubを使用した分散キャッシュ無効化の仕組みが正常に動作するようになり、複数のインスタンス間でキャッシュの一貫性が維持されるようになりました。このトラブルシューティングの経験は、分散システムにおけるイベント伝播の設計と実装に関する貴重な知見を提供しました。\n"
}